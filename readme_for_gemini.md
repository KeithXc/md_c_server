# Project Context for Gemini

This file provides a quick overview of the "C Markdown Blog" project for Gemini to ensure a smooth continuation of our work in future sessions.

## 1. Project Goal

The primary goal of this project is to create a simple, lightweight, and fast web server entirely in C. Its sole purpose is to find Markdown files (`.md`) in a specific directory, convert them to HTML on the fly, and serve them to a web browser.

## 2. Core Technologies

-   **Language**: C (std=c11)
-   **Build System**: CMake (configured to automatically find all source files in `src/`)
-   **Core Libraries**:
    -   `mongoose`: An embedded web server library for handling HTTP requests.
    -   `cmark`: A library for parsing Markdown and converting it to HTML.
    -   `zlib`: For Gzip compression of HTTP responses.

## 3. Directory Structure

The project is organized into the following directories:

-   `bin/`: **Output** for the final compiled `md_web_server` executable. (Ignored by Git)
-   `build/`: **Temporary files** generated by CMake and the compiler. (Ignored by Git)
-   `cache/`: **Cached data** for compressed HTML responses. (Ignored by Git)
-   `md/`: **Content** directory where user places their `.md` files.
-   `src/`: **Source code** directory.
    -   `server.c`: Handles server initialization, socket listening, and routing.
    -   `routes_*.c`/`.h`: Contain logic for specific routes (`/` and `/post/*`).
    -   `cache.c`/`.h`: Implements the caching and Gzip compression logic.
    -   `utils.c`/`.h`: Provides shared utility functions.
    -   `mongoose.c`/`.h`: The Mongoose library source files.
-   `templates/`: HTML templates.

## 4. Current Status & Features

1.  **Markdown to HTML**: Converts `.md` files to HTML on the fly using `cmark`.
2.  **Gzip Compression**: Compresses the generated HTML with `zlib` before sending.
3.  **Caching**: Caches the compressed HTML in the `cache/` directory. The cache is invalidated automatically if the source `.md` file is modified.
4.  **Control Scripts**: `run.sh` compiles and starts the server, while `stop.sh` terminates it.

## 5. How to Build and Run

Use the provided shell scripts:
-   **Start server**: `./run.sh`
-   **Stop server**: `./stop.sh`

The server will be accessible at `http://localhost:8000`.

## 6. Gemini's Debugging Workflow Examples

### Example 1: The Double `Content-Length` Header

We previously debugged an issue where browser tabs would spin indefinitely.

1.  **Problem**: Browser tab stuck in a loading state.
2.  **Verification**: `curl -v` showed the server was sending **two** `Content-Length` headers. This was caused by misusing `mg_http_reply`.
3.  **Solution**: We switched to manually constructing the header block and sending it with `mg_printf`, then setting `c->is_draining = 1` to gracefully close the connection.
4.  **Takeaway**: `curl -v` is invaluable for inspecting raw server responses.

### Example 2: The Phantom `Content-Length: %zu` Bug

More recently, we fixed a bug where `curl` and `wget` reported an `Invalid Content-Length` header, even though browsers could render the page.

1.  **Problem**: `curl` and `wget` showed the server was literally sending `Content-Length: %zu` instead of a number. Browsers worked fine due to their high fault tolerance (they ignored the bad header and relied on the connection closing).
2.  **Initial Hypothesis**: The `mg_printf` function was not correctly formatting the `%zu` specifier for the `size_t` type.
3.  **Debugging Rabbit Hole**: We spent a significant amount of time trying to fix this. We replaced `mg_printf` with a manual header construction using `snprintf` and later a custom integer-to-string function. However, **none of these code changes appeared to have any effect**, which seemed logically impossible.
4.  **Root Cause Analysis**: The true problem was not the C code itself, but the **build and execution environment**. The original `stop.sh` script was unreliable and only killed the most recent server process, leaving numerous old, zombie processes running. We were sending our test requests to these old zombie processes, which were still running the original buggy code.
5.  **Solution**:
    a.  Killed all zombie processes using `pkill -f md_web_server`.
    b.  Implemented a robust, manual header construction in `routes_post.c` that uses a custom `u64_to_str` function to avoid any `printf` family formatting issues.
    c.  Made the `stop.sh` script robust by switching it to `pkill`.
    d.  Modified `run.sh` to call `stop.sh` at the very beginning, ensuring a clean state for every run.
6.  **Takeaway**: If code changes seem to have no effect, rigorously investigate the build, deployment, and execution process. Ensure you are actually running the code you just changed and that no old processes are still active.
