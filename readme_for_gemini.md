# Project Context for Gemini

This file provides a quick overview of the "C Markdown Blog" project for Gemini to ensure a smooth continuation of our work in future sessions.

## 1. Project Goal

The primary goal of this project is to create a simple, lightweight, and fast web server entirely in C. Its sole purpose is to find Markdown files (`.md`) in a specific directory, convert them to HTML on the fly, and serve them to a web browser.

## 2. Core Technologies

-   **Language**: C (std=c11)
-   **Build System**: CMake (configured to automatically find all source files in `src/`)
-   **Core Libraries**:
    -   `mongoose`: An embedded web server library for handling HTTP requests.
    -   `cmark`: A library for parsing Markdown and converting it to HTML.
    -   `zlib`: For Gzip compression of HTTP responses.

## 3. Directory Structure

The project is organized into the following directories:

-   `bin/`: **Output** for the final compiled `md_web_server` executable. (Ignored by Git)
-   `build/`: **Temporary files** generated by CMake and the compiler. (Ignored by Git)
-   `cache/`: **Cached data** for compressed HTML responses. (Ignored by Git)
-   `md/`: **Content** directory where user places their `.md` files.
-   `src/`: **Source code** directory.
    -   `server.c`: Handles server initialization, socket listening, and routing.
    -   `routes_*.c`/`.h`: Contain logic for specific routes (`/` and `/post/*`).
    -   `cache.c`/`.h`: Implements the caching and Gzip compression logic.
    -   `utils.c`/`.h`: Provides shared utility functions.
    -   `mongoose.c`/`.h`: The Mongoose library source files.
-   `templates/`: HTML templates.

## 4. Current Status & Features

1.  **Markdown to HTML**: Converts `.md` files to HTML on the fly using `cmark`.
2.  **Gzip Compression**: Compresses the generated HTML with `zlib` before sending.
3.  **Caching**: Caches the compressed HTML in the `cache/` directory. The cache is invalidated automatically if the source `.md` file is modified.
4.  **Control Scripts**: `run.sh` compiles and starts the server, while `stop.sh` terminates it.

## 5. How to Build and Run

Use the provided shell scripts:
-   **Start server**: `./run.sh`
-   **Stop server**: `./stop.sh`

The server will be accessible at `http://localhost:8000`.

## 6. Gemini's Debugging Workflow Example

We recently debugged an issue where browser tabs would spin indefinitely after loading a Markdown page. This serves as a record of the successful diagnostic process.

1.  **Problem**: User reported that the browser tab was stuck in a loading state.
2.  **Hypothesis**: The initial guess was an issue with HTTP headers, specifically `Content-Length`, or improper connection handling by the server.
3.  **Verification Tool**: The key to solving this was using `curl` with the verbose flag: `curl -v http://localhost:8000/post/some_file.md`. Relying only on browser developer tools was insufficient.
4.  **Analysis**: The `curl` output clearly showed the server was sending **two** `Content-Length` headers in its response. This was caused by an incorrect use of the `mg_http_reply` function, which automatically added a `Content-Length: 0` header for an empty body, conflicting with the one we added manually to the headers string.
5.  **Solution**: The correct fix was to stop using `mg_http_reply` for this specific case. Instead, we manually constructed the entire header block (including the correct `Content-Length`) as a single string and sent it using `mg_printf`. Crucially, we then set the `c->is_draining = 1` flag on the connection. This tells Mongoose to close the connection gracefully after the response is fully sent, resolving the browser's waiting state.
6.  **Takeaway**: When dealing with low-level HTTP responses, always verify the exact output with a tool like `curl -v`. It provides unambiguous insight into the raw server response.